<!DOCTYPE html>
<html>
<head>
    <title>3D Clock Background</title>
    <style>
        body { margin: 0; overflow: hidden; } /* 스크롤바 제거 */
        canvas { display: block; } /* 캔버스 기본 여백 제거 */
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/examples/js/loaders/FontLoader.js"></script>
<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/"
    }
  }
</script>

<script type="module">

  import * as THREE from 'three';
  // JSM 경로에 TextGeometry가 아직 있다면
  import { FontLoader } from 'three/addons/loaders/FontLoader.js'; 
  import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { TextGeometry } from 'three/addons/geometries/TextGeometry.js'; 


  // 이제 THREE.을 붙이지 않고 FontLoader를 바로 사용할 수 있습니다.
  const loader0 = new FontLoader(); 

  window.myGlobalLoader = loader0;

  const FONT_CANDIDATES = {
    helvetiker: "https://raw.githubusercontent.com/mrdoob/three.js/r160/examples/fonts/helvetiker_regular.typeface.json",
    helvetiker_bold: "https://raw.githubusercontent.com/mrdoob/three.js/r160/examples/fonts/helvetiker_bold.typeface.json",
    optimer: "https://raw.githubusercontent.com/mrdoob/three.js/r160/examples/fonts/optimer_regular.typeface.json",
    optimer_bold: "https://raw.githubusercontent.com/mrdoob/three.js/r160/examples/fonts/optimer_bold.typeface.json",
    gentilis: "https://raw.githubusercontent.com/mrdoob/three.js/r160/examples/fonts/gentilis_regular.typeface.json",
    gentilis_bold: "https://raw.githubusercontent.com/mrdoob/three.js/r160/examples/fonts/gentilis_bold.typeface.json",
    roboto: "https://raw.githubusercontent.com/7dir/json-fonts/refs/heads/master/fonts/cyrillic/roboto/Roboto_Regular.json",
    roboto_bold: "https://raw.githubusercontent.com/7dir/json-fonts/refs/heads/master/fonts/cyrillic/roboto/Roboto_Bold.json"
  };

        // 폰트 파일 URL (Three.js 예제 폰트 사용)
        const FONT_URL = FONT_CANDIDATES.helvetiker_bold

        // 1. Scene, Camera, Renderer 설정
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 배경 꾸미기

        const cubeLoader = new HDRCubeTextureLoader();
        const hdrPath = 'https://threejs.org/examples/textures/cube/pisaHDR/'
        const hdrArray = [
            'px.hdr', 'nx.hdr', // +X, -X (이 예제는 png가 아닌 jpg 파일을 사용하고, 파일명도 다릅니다.)
            'py.hdr', 'ny.hdr', // +Y, -Y
            'pz.hdr', 'nz.hdr'  // +Z, -Z
        ]

if (false){
        const envMap = cubeLoader.setPath(hdrPath).load(hdrArray);
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        // const envMap = pmremGenerator.fromEquirectangular(texture).texture;

        const envMapOptimized = pmremGenerator.fromCubemap( envMap ).texture;
        pmremGenerator.dispose(); // Generator는 사용 후 해제

        scene.background = envMap; // 배경으로도 사용
        scene.environment = envMapOptimized; // PBR 환경 설정의 표준

        // 리소스 정리
        texture.dispose();
        pmremGenerator.dispose();

}

const HDR_FILE_URL = "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/warm_restaurant_night_2k.hdr"
// "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/university_workshop_2k.hdr"
// "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/citrus_orchard_puresky_2k.hdr"
// 'cit.hdr'; // ⭐ 여기에 다운로드한 파일의 URL을 넣어야 합니다.

new RGBELoader()
    .setDataType(THREE.FloatType)
    .load(HDR_FILE_URL, function (texture) {

        // PMREMGenerator를 사용하여 HDR 텍스처를 큐브맵으로 변환
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;
        const envMapOptimized = pmremGenerator.fromCubemap(envMap).texture;

        // 리소스 정리
        texture.dispose();
        pmremGenerator.dispose();

        // 장면 및 재질에 적용
        scene.background = envMap;  
        scene.environment = envMapOptimized;  
    });




        // 2. 조명 설정
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // 주변광
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1); // 점광원

        pointLight.position.set(5, 5, 5);
            pointLight.castShadow = true;
            pointLight.shadow.mapSize.width = 1024; // 그림자 품질 설정
            pointLight.shadow.mapSize.height = 1024;

        scene.add(pointLight);




            // 4. (필요하다면) 그림자를 받을 바닥 추가
            const planeGeometry = new THREE.PlaneGeometry(20, 10);
            const planeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xEE9933,    
                transparent: true, 
                opacity: 0.3 });

            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -3; // 텍스트 아래에 배치
            plane.receiveShadow = true; // 그림자를 받도록 설정
            scene.add(plane);


        
        // 3. 텍스트 객체 변수 및 로더
        let clockText;
        const loader = window.myGlobalLoader // new THREE.FontLoader();

        loader.load(FONT_URL, function (font) {
            // 폰트 로드 성공 후 실행
            
            // const textMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, flatShading: true }); // 청록색 재질
            const textMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD1DC, 
                metalness: 1.0,  // 금속성 최대로
                roughness: 0.2,  // 반짝임을 위해 거칠기 낮춤
            });


            // textMaterial.envMap = envMap; // 재질의 환경맵으로 설정
            // textMaterial.needsUpdate = true; // 재질 업데이트




            const createText = (textString) => {
                // 기존 텍스트가 있으면 제거하고 리소스 해제
                if (clockText) {
                    scene.remove(clockText);
                    clockText.geometry.dispose();
                }

                // 텍스트 지오메트리 생성 옵션
                const textGeometry = new TextGeometry(textString, {
                    font: font,
                    size: 4.5, // 텍스트 크기
                    depth: 0.3, // 텍스트 깊이
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.05,
                    bevelSize: 0.02,
                    bevelOffset: 0,
                    bevelSegments: 5
                });

                // 텍스트 중앙 정렬
                textGeometry.computeBoundingBox();
                const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
                textGeometry.translate(centerOffset, 0, 0);

                clockText = new THREE.Mesh(textGeometry, textMaterial);

                clockText.castShadow = true; 
                scene.add(clockText);



            };

            // 초기 텍스트 생성
            createText(getCurrentTime());
            
            // 4. 애니메이션 루프
            function animate() {
                requestAnimationFrame(animate);

                // 텍스트 업데이트: 매 프레임마다 시간을 체크하고, 초(second)가 바뀌었을 때만 업데이트
                const newTime = getCurrentTime();
                if (clockText && clockText.geometry.parameters.options.text !== newTime) {
                     createText(newTime);
                }
                
                // 동적 배경 효과: 카메라를 천천히 회전
                camera.position.x = Math.sin(Date.now() * 0.0001) * 12;
                camera.position.y = Math.cos(Date.now() * 0.0001) * 12;
                camera.lookAt(scene.position); // 항상 텍스트를 바라보도록 설정

                renderer.render(scene, camera);
                if (clockText) {
                        clockText.rotation.z += 0.005; 
                }
            }

            animate(); // 폰트 로드 완료 후 애니메이션 시작

        }); // loader.load 끝

        // 현재 시간을 "HH:MM:SS" 형식으로 반환하는 함수
        function getCurrentTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }

        // 5. 반응형 처리
        window.addEventListener('resize', () => {
            // 렌더러 크기 업데이트
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
    </script>
</body>
</html>
